#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  frontFlipLeds,  sensorLEDtoVCC)
#pragma config(Sensor, dgtl2,  backFlipLeds,   sensorLEDtoVCC)
#pragma config(Sensor, dgtl3,  tankLeds,       sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  lDriveEnc,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  rDriveEnc,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  liftEnc,        sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  clawEnc,        sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           lClaw,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rDrive,        tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port3,           brLift,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           mrLift,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           trLift,        tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port6,           tlLift,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           mlLift,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           blLift,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           lDrive,        tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port10,          rClaw,         tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_4)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

#define RX 0
#define RY 1
#define LY 2
#define LX 3

#define LIFT_UP_BTN (vexRT[Btn5U])
#define LIFT_DWN_BTN (vexRT[Btn5D])

#define CLAW_OPEN_BTN (vexRT[Btn6U])
#define CLAW_CLOSE_BTN (vexRT[Btn6D])


#define setRDrive(pwr) motor[rDrive] = pwr
#define setLDrive(pwr) motor[lDrive] = pwr

#define setClaw(pwr) motor[lClaw] = \
	motor[rClaw] = \
	pwr

#define setLift(pwr) \
	motor[blLift] = \
		motor[mlLift] = \
		motor[tlLift] = \
		motor[trLift] = \
		motor[mrLift] = \
		motor[brLift] = \
		pwr



//void clearLCD() {
//	clearLCDLine(0);
//	clearLCDLine(1);
//}


int* arcade(int* arr, int move, int rot) {
	arr[0] = move + rot;
	arr[1] = move - rot;
	return arr;
}

void setDrive(int* pwrs) {
	setLDrive(pwrs[0]);
	setRDrive(pwrs[1]);

}


typedef struct {
	bool out;
	word valLast;

} Toggle;

bool upToggle(Toggle* toggle, word in) {
	if(in != toggle->valLast)
		toggle->out = true;
	else
		toggle->out = false;
	toggle->valLast = in;
	return toggle->out;
}

bool pressToggle(Toggle* toggle, word in) {
	if(toggle->out && in)
		return true;
	else
		return false;
}

typedef struct {
	int targ,
		val,
		error,
		errLast,
		out,
		thresh;
	float prop,
		integ,
		deriv,
		kP,
		kI,
		kD;
	char sensorPort,
		bIsOnTarg;
} Pid;

void initPid(Pid* pid, float kP,	float kI, float kD, int thresh, char sensorPort) {
	pid->kP = kP;
	pid->kI = kI;
	pid->kD = kD;
	pid->thresh = thresh;
	pid->error =
		pid->integ =
		pid->out = 0;
}

void setPid(Pid* pid, int target) {
	pid->targ = target;
	pid->errLast =
		pid->integ = 0;
}

int upPid(Pid* pid) {
	pid->val = SensorValue[pid->sensorPort];
	pid->errLast = pid->error;
	pid->error = pid->targ - pid->val;
	pid->prop = pid->error * pid->kP;
	pid->integ += pid->error * pid->kI;
	if(fabs(pid->integ) > 127)
		pid->integ = 127 * sgn(pid->integ);
	pid->deriv = (pid->error - pid->errLast) * pid->kD;
	pid->bIsOnTarg = (abs(pid->targ - pid->val) <= pid->thresh)
		? 1
		: 0;
	return pid->out = round(pid->prop + pid->integ + pid->deriv);
}

Toggle liftUpToggle,
	liftDwnToggle;

Pid lDrivePid,
	rDrivePid,
	liftPid,
	clawPid;

const int liftSetPts[3] = {0, 824, 1098};

task pidCtls() {
	while(true) {
		upPid(&rDrivePid);
		upPid(&lDrivePid);
		upPid(&liftPid);
		upPid(&clawPid);
		wait1Msec(20);
	}
}

void pre_auton() {
	initPid(&liftPid, .1, 0, 0, 250, 22);
	initPid(&rDrivePid, .1, 0, 0, 50, 21);
	initPid(&lDrivePid, .1, 0, 0, 50, 20);
}

task autonomous() {

  setPid(&lDrivePid, 500);
  setPid(&rDrivePid, 500);
  setPid(&liftPid, 1125);
	while(!lDrivePid.bIsOnTarg) {
		wait1Msec(20);
	}

}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol() {
	int stick[4],
		drivePwrs;
	signed char liftTargCt = 0,
		liftTargCtLast;
	const signed char stickThresh = 7;

	while (true) {
	  for(int i = 0; i < 4; i++)
			stick[i] =
				(fabs(vexRT[i]) >= stickThresh)
				? vexRT[i]
				: 0;

		upToggle(&liftUpToggle, LIFT_UP_BTN);
		upToggle(&liftDwnToggle, LIFT_DWN_BTN);
		liftTargCtLast = liftTargCt;

		liftTargCt += (pressToggle(&liftUpToggle, LIFT_UP_BTN) ^ pressToggle(&liftDwnToggle, LIFT_DWN_BTN))
			? (pressToggle(&liftUpToggle, LIFT_UP_BTN))
				? 1
				: -1
			: 0;

		if(liftTargCt > 2)
			liftTargCt = 0;
		else if(liftTargCt < 0)
			liftTargCt = 2;

		setDrive(arcade(&drivePwrs, stick[LY], stick[RX]));
		if(liftTargCt != liftTargCtLast)
			setPid(&liftPid, liftSetPts[liftTargCt]);
		setLift(upPid(&liftPid));
		setClaw((CLAW_OPEN_BTN ^ CLAW_CLOSE_BTN)
			? (CLAW_OPEN_BTN)
				? 127
				: -127
			: 0);

		wait1Msec(20);
	}
}
